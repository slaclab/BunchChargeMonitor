# These are the records that transform tick counts to time in nanoseconds,
# by using the sampling frequency of the ADCs.

# Remember to subtract 28 from the number of samples, because the first 28
# words are used by the header.

# Giving the frequency in Hz, calculate the time in ns between each sample
record (calc, "$(P):$(CHAN):CLK_PERIOD") {
  field(DESC, "Time between samples in ns")
  field(INPA, "$(P):$(CHAN):AmcClkFreq CP")
  field(CALC, "1000000000/(2 * A)")
}

# Calculate the time correspondent to the number of samples of the pre-edge
# of the weight function.
record (calc, "$(P):$(CHAN):TIME_PRE_RBV") {
  field(DESC, "Duration of pre-edge in ns")
  field(INPA, "$(P):$(CHAN):CLK_PERIOD CP")
  field(INPB, "$(P):$(CHAN):NumSamp0 CP")
  field(CALC, "A*B")
}

# Calculate the time correspondent to the number of samples of between edges
# of the weight function.
# The TrigDelay is half the size of NumSamp0 and NumSamp1.
record (calc, "$(P):$(CHAN):TIME_MID_RBV") {
  field(DESC, "Duration between edges in ns")
  field(INPA, "$(P):$(CHAN):CLK_PERIOD CP")
  field(INPB, "$(P):$(CHAN):TrigDelay1 CP")
  field(INPC, "$(P):$(CHAN):NumSamp0 CP")
  field(CALC, "B*2<C ? C*2*A : B*2*A")
}

# Calculate the time correspondent to the number of samples of the pos-edge
# of the weight function. The 28 words from the header should not be discounted
# in this case because the starting time of the post-edge is related to trigger
# delay, which was already discounted.
record (calc, "$(P):$(CHAN):TIME_POS_RBV") {
  field(DESC, "Duration of pos-edge in ns")
  field(INPA, "$(P):$(CHAN):CLK_PERIOD CP")
  field(INPB, "$(P):$(CHAN):NumSamp1 CP")
  field(CALC, "B * A")
}

# Desired time of the weight function pre-edge
record (ai, "$(P):$(CHAN):TIME_PRE") {
  field(DESC, "Duration of pre-edge in ns")
  field(PINI, "YES")
  info(autosaveFields, "VAL")
}

# Calculate the number of samples of the pre-edge of the weight function 
# giving the correspondent time and writes it to the firmware. Only even
# numbers are allowed in the FPGA register (that is why we use ((~0)-1)&
record (calcout, "$(P):$(CHAN):NumSamp0_CLC") {
  field(DESC, "Number samples of pre-edge")
  field(INPA, "$(P):$(CHAN):TIME_PRE CP")
  field(INPB, "$(P):$(CHAN):AmcClkFreq CP")
  field(CALC, "((~0)-1)&FLOOR((2*A*B)/1000000000)")
  field(OUT, "$(P):$(CHAN):NumSamp0 PP")
  field(DOPT, "Use CALC")
}

# Desired time of the weight function between edges
record (ai, "$(P):$(CHAN):TIME_MID") {
  field(DESC, "Duration of between edge in ns")
  field(PINI, "YES")
  info(autosaveFields, "VAL")
}

# Time between edges is doubled related to the edges. Also, timing zero for
# this time is exactly timing zero for the pre-edge. So, we must not allow
# that the between edges time keeps greater than the pre-edge.
record (calc, "$(P):$(CHAN):TIME_MIDC") {
  field(DESC, "Duration of between edge in ns")
  field(INPA, "$(P):$(CHAN):TIME_PRE CP")
  field(INPB, "$(P):$(CHAN):TIME_MID CP")
  field(CALC, "A<B? B/2 : A/2")
}

# Calculate the number of samples of between edges of the weight function 
# giving the correspondent time and writes it to the firmware. The time
# here is twice the time in pre and post edges. Only even numbers are allowed
# in the FPGA register (that is why we use ((~0)-1)&).
record (calcout, "$(P):$(CHAN):TrigDelay1_CLC") {
  field(DESC, "Number samples of between edges")
  field(INPA, "$(P):$(CHAN):TIME_MIDC CP")
  field(INPB, "$(P):$(CHAN):AmcClkFreq CP")
  field(CALC, "((~0)-1)&FLOOR((2*A*B)/1000000000)")
  field(OUT, "$(P):$(CHAN):TrigDelay1 PP")
  field(DOPT, "Use CALC")
}

# Desired time of the weight function pos-edge
record (ai, "$(P):$(CHAN):TIME_POS") {
  field(DESC, "Duration of pos-edge in ns")
  field(PINI, "YES")
  info(autosaveFields, "VAL")
}

# As per requirement, The maximum time of all windows summed up must not exceed
# 1000 ns, or 1 us.
record (calc, "$(P):$(CHAN):TIME_POSC") {
  field(DESC, "Duration of pos-edge in ns")
  field(INPA, "$(P):$(CHAN):TIME_MIDC CP")
  field(INPB, "$(P):$(CHAN):TIME_POS CP")
  field(CALC, "A*2+B>1000 ? 1000-A*2 : B")
}

# Calculate the number of samples of the pos-edge of the weight function 
# giving the correspondent time and writes it to the firmware. Only even
# numbers are allowed in the FPGA register (that is why we use ((~0)-1)&).
record (calcout, "$(P):$(CHAN):NumSamp1_CLC") {
  field(DESC, "Number samples of pos-edge")
  field(INPA, "$(P):$(CHAN):TIME_POSC CP")
  field(INPB, "$(P):$(CHAN):AmcClkFreq CP")
  field(CALC, "((~0)-1)&FLOOR((2*A*B)/1e9)")
  field(OUT, "$(P):$(CHAN):NumSamp1 PP")
  field(DOPT, "Use CALC")
}

# Create a waveform with the sampling time. This will be the X axis of the
# waveform.
record (aSub, "$(P):$(CHAN):WF_TIME") {
  field(SNAM, "calcTimeArray")
  field(FTA, "LONG")
  field(FTVA, "DOUBLE")
  field(NOA, "2020")
  field(NOVA, "2020")
  field(INPA, "$(P):$(CHAN):AmcClkFreq CP")
}
